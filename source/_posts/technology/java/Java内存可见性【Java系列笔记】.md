---
title: Java内存可见性【Java系列笔记】
tags:
  - Java
categories:
  - Technology
  - Java
date: 2017-04-07 12:18:00
---

Java 内存可见性
<!-- more -->

***
# 共享变量
[视频 Java 内存可见性](http://www.imooc.com/learn/352 "Java 内存可见性")

解决针对**线程共享变量**的**数据争用**问题
概念：
>可见性：一个线程对共享变量值的修改，能够及时地被其他线程看到。
共享变量：一个变量在多个线程的工作内存中存在副本，那么这个变量就是这几个线程的共享变量

# Java 内存模型 （JMM）
>Java Memory Model 描述了 Java 各种变量（线程共享变量）的访问规则，以及在 JVM 中‘将变量储存到内存’和‘从内存中读取变量’这样的底层细节

1. 所有变量都储存在`主内存`中
2. 每个线程都有自己`独立的工作内存`，里面保存该线程使用到的变量的副本（主内存中该变量的一份拷贝）

图解 JMM
![JMM](http://ogy9ohfjc.bkt.clouddn.com/java-kejianxing/JMM.png "JMM")

规定
1. 线程对共享变量所有的操作都必须在自己的工作内存中进行，不能直接从主内存中读写（不能越级）
2. 不同线程之间也无法直接访问其他线程的工作内存中的变量，线程间变量值的传递需要通过主内存来进行。（同级不能相互访问）

共享变量可见性的实现原理：
线程1对共享变量的修改要被线程2及时看到的话，要经过如下步骤：
1. 把工作内存1中更新的变量值刷新到主内存
2. 把主内存中的变量的值更新到工作内存2中

# synchronized 实现可见性
synchronized
- 原子性（同步）：保证只有一个线程可以对当前变量进行操作
- 可见性 

JMM 关于 synchronized 的两条规定：
1. 线程解锁前（退出synchronized前），必须把共享变量值刷新到主内存中
2. 线程加锁前（进入synchronized前），必须清空当前工作内存共享变量的值，所以使用共享变量时，需要到共享变量中读取最新的值 （当然要和第一条是用一把锁）
3. 这就保证了线程解锁前对共享变量的修改能够在下一次加锁的时候对其他线程可见

synchronized 实现可见性：
1. 获得互斥锁
2. 清空工作内存
3. 从主内存拷贝共享变量的最新副本到工作内存
4. 执行代码
5. 刷新更改后的共享变量到主内存
6. 释放互斥锁

>重排序：代码的书写顺序和执行顺序不同，指令重排序是编译器或处理器为了提高程序性能而进行的优化。

重排序：
1. 编译器优化
2. 指令级并行（处理器优化）
3. 内存系统的重排序（处理器优化）

>as-if-serial 无论如何重排序，程序执行的结果应该与代码书写顺序的执行结果一致

1. 编译器，runtime和处理器可以保证单线程情况下的一致性
2. 但是多线程交错执行的时候，重排序可能会造成内存可见性问题

导致共享变量在线程间不可见的原因：
1. 线程的交叉执行（synchronized 的原子性，可以避免交叉执行）
2. 重排序结合线程交叉执行
3. 共享变量更新后的值没有在工作内存与主内存之间及时更新（synchronized的可见性规范）

# volatile 实现可见性
1. volatile 可以实现可见性
2. 不能实现原子性

`volatile` 如何实现内存可见性
1. 通过加入内存屏障和禁止重排序优化来实现
2. 对 `volatile` 变量执行写操作的时候，会在写操作后加入一条 `store` 屏障指令
    强制把共享变量刷新到主内存中去
3. 对 `volatile` 变量执行读操作的时候，会在写操作前加入一条 `load` 屏障指令
    强制读取主内存中的共享变量

使用场景：
1. 对变量写入操作不依赖当前值
    不满足：`number++`，`count = count * 5`
2. 该变量没有包含在具有其他变量的不变式中

讲道理就是不能解决原子性的问题，所以，没有 synchronized 用的广泛

Everything pays a price

synchronized 和 volatile 比较
1. volatile 不需要加锁，所以轻便，不会阻塞线程
2. 从可见性的角度来说，volatile的读相当于加锁，写相当于解锁

# 遗补
1. final 也可以保证可见性
2. 在多线程高并发的情况下才有可见性的问题，所以一般情况下可见性还是能保证的
3. long 和 double 是64位的，读写可能不是原子操作
    jvm 循序分两次32位读写

