---
title: Java垃圾回收机制【Java系列笔记】
tags:
  - Java
categories:
  - Technology
  - Java
date: 2017-04-11 20:38:00
---

Java 垃圾回收机制

Reference:
[JVM 自动内存管理视频](http://www.jikexueyuan.com/course/2098.html "JVM 自动内存管理视频")
<!-- more -->

***

# 可回收对象的判定方法
1. 引用计数算法
2. 可达性分析

## 引用计数算法
1. 给每一个对象添加一个引用计数器
2. 每当有一个地方引用它，计数器值就+1
3. 当引用失效的时候，计数器值就-1
4. 任何时刻计数器为零的时候对象就是没有在被使用的

缺陷：堆上对象的循环引用，这些对象的计数器值始终是1

## 可达性分析算法
`GC-root` 的对象作为起始点，从这些节点向下搜索，搜索所有的路径成为 `引用链(Reference Chain)` 。当 `GC-root` 到一个对象不可达时，那么这个对象是不可用的。

Java中可以作为 GC-root：
1. 虚拟机栈（栈帧中的本地变量表）中的引用对象
2. 方法区中类静态属性的引用对象
3. 方法区中常量的引用对象
4. 本地方法栈中native方法引用的对象

<br>
***
<br>

# 垃圾收集算法

## 标记清除算法（最基本）
算法分为两个阶段：
1. 标记：在标记阶段标记出所有需要清除的对象
2. 清除：在标记完成后统一清除这些对象

![标记清除算法](  https://menuet-1258369060.cos.ap-shanghai.myqcloud.com/java/gc-biaojiqingchusuanfa.png "标记清除算法" )

缺陷：
1. 标记清除之后会产生大量不连续的内存碎片
（之后需要分配较大连续内存的时候，可能出现内存不足）
2. 效率不算太高

这是最基础的垃圾回收算法，后面的算法都是基于标记清除算法的改进。

## 复制算法
`复制算法`主要解决的是`标记清楚算法`回收效率不高的问题

原理：
1. 将可用内存划分为大小相等的两块
2. 每次只用一块
3. 当这一块内存用完的时候，就将还存活的对象复制到另一块内存上。然后把当前的这块内存清空。

![复制算法](https://menuet-1258369060.cos.ap-shanghai.myqcloud.com/java/gc-fuzhisuanfa.png "复制算法" )

优点：分配内存的效率高，只需要移动堆顶的指针就好了
缺点：内存大小只剩下一半了。

赋值算法适合应用于对象存活率较低的算法，这样需要复制的对象较少。所以利用在这种方法进行`新生代内存`的回收。根据 IBM 的研究，新生代中的对象大部分为朝生夕死，所以不需要按 `1:1` 的比例来划分内存。而是 `HotSpot` 将内存划分为:
1. 一块较大的`使用空间` （80%）
2. 两块较小的`拯救空间` （10%，10%）

方式：
1. 内存回收的时候，将`使用空间`和一块`拯救空间`中存活的对象复制到另一块`拯救空间`，然后同时回收`使用空间`和前者的`拯救空间`的内存。这样内存使用率就达到了90%。
2. 当然在极端情况下，存活的对象占用内存的大小可能超过10%，这个时候就要依赖其他的内存了。比如，利用老年代来进行`空间分配担保`。

## 标记整理算法
`标记整理算法`主要解决`标记清除算法`的不连续的内存碎片问题。这是`老年代`应用最多的垃圾回收算法：
1. 对象存活率高，复制算法的效率会下降
2. 当没有额外内存可以进行担保，又不想损失一半的内存，`复制算法`也不合适。

原理：
1. 标记：过程和`标记清除算法`的标记阶段一样
2. 整理：让所有对象向一端移动，然后对另一端进行清理。

![标记整理算法](https://menuet-1258369060.cos.ap-shanghai.myqcloud.com/java/gc-biaojizhenglisuanfa.png "标记整理算法" )

缺陷：
1. 相对于`标记清除算法`，对系统的停顿的时间会更长
2. 因为在标记阶段和整理阶段都要停止虚拟机当前的执行的线程，然后对静止的JVM的堆内存快照进行收集。

## 分代收集算法
根据对象存活周期的不同将内存划分为不同的块：
1. 新生代
2. 老年代

然后根据不同年代的特点（对象存活的时间）进行最适当的算法收集

# HotSpot 虚拟机算法的实现
1. 可回收对象的判定：`GC root` 的枚举
2. 安全点和安全区

## GC-root 枚举
难点：
1. 检查范围大：即使不看虚拟机栈，只看方法区，内存就非常的大
2. 时间敏感：必须在快照中进行，对象引用关系不能变化

## 准确式GC 和 OOP-MAP
准确式GC：
1. 含义：虚拟机能够知道某个位置的数据具体是什么类型（如果是引用类型就是 GC-Root
2. 举个例子: 内存中有一个32bit的整数123456，它到底是一个`reference类型`指向123456的内存地址还是一个`数值为123456的整数`，虚拟机将有能力分辨出来，这样才能在GC的时候准确判断堆上的数据是否还可能被使用。

OOP-MAP
HotSpot 还是用一组叫做 `OOP-MAP` 的数据结构来直接得到哪些地方存放了对象的引用。
1. 类加载完成的时候，JVM把内存布局中什么偏移量上是什么类型的数据计算出来
2. JVM 的编译过程中，也会在特定位置，记录虚拟机栈和寄存器中那些位置上是对象的引用。
3. 垃圾回收的时候就可以直接扫描 `OOP-MAP` 来得到 `GC-ROOT` 的信息

但是也产生了一个问题，因为引用关系会频繁地发生变化，如果对每一条指令都生成一个 `OOP-MAP`， 那么这会占用大量的内存空间。 

## 安全点和安全区
安全点：
1. HotSpot 只在特定的位置记录了这些信息，这些位置被称为`安全点`。
2. 也就是说在线程执行的时候，只有执行到安全点的时候，才能暂停线程，开始GC过程
3. 安全点的数量要适当

如何在安全点终端线程：
1. 抢先式中断：
    在GC发生的时候，首先把所有线程中段，这个时候如果有线程不在安全上，那么恢复它，让这个线程继续跑到安全点上。
2. 主动式终端：
    GC 不直接对线程进行操作，而是设置一个标志。每个线程执行的时候主动去访问这个标志，发现这个标志为真的时候就把这个自己的线程主动挂起。（目前，商用虚拟机都使用这个）。

安全区：
1. 如果线程没有在执行（休眠或者阻塞的状态），这个时候没法响应JVM的终端请求（不会运行到 安全点）
2. 这个时候线程的引用关系不会发生变化，所以就可以标识自己进入了安全区域，可以看成安全点的扩展，在这个过程当中都可以发起 gc
































