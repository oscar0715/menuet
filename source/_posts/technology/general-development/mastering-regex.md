---
title: Mastering Regular Expressions
tags:
  - Regex
categories:
  - Technology
  - General
date: 2017-01-01 20:57:15
---
据说 Mastering Regular Expression 是研究正则表达式的必读经典。那就研究一下咯。
<!-- more -->

***

# 第一章 正则表达式入门
完整的正则表达式由两种字符构成：
1. 元字符 (Metacharacter)：也就是特殊字符
2. 文字 (literal)：就是普通字符

正则表达式的思维框架：正则表达式由小的构建模块单元 (building block unit) 组成。

这个部分的我们介绍的是 egrep 中的正则语法。

## Egrep 元字符：
1. 脱字符号 `^` ：代表一行的开始
2. 美元字符 `$` ：代表一行的结束

举个例子：
1. `^cat` 只匹配一行开头的 cat ，`^` 锚定了行的开头
2. `cat$` 只匹配行末的 cat
3. `^$` 匹配空行

## 字符组
1. `[]` 方括号表示字符组，是同一个位置能够匹配的若干字符，所以意思是或
    - 例子：`[ae]` 表示 a 或者 e。 
    - `gr[ae]y` 可以找到 gray 或者 grey
    - `[Ss]imth` 可以找到 Smith 或者 smith
2. 字符组元字符
    - 字符组中也有特殊字符
    - 连字符 `-` 表示一个区间。 `[0-9]` 和 `[a-z]` 是常用的匹配数字和小写字母的简便方式。
    `[0-9A-Z_!.?]` 能够匹配一个数字，大写字母，下划线，惊叹号，点号，或者是问号。
    - `-` 只有在字符组内部才是元字符。
    - 例外，如果连字符在字符组的第一个位置，连字符则不是特殊字符。（不然没法表示一个区间嘛）
    - 反过来 `?` `.` 通常来说是元字符，但是在字符组中只代表普通字符。

## 排除型字符组
`[^]` 以 `^` 开头的字符组就会匹配任何一个未列出的字符，`^` 表示排除。
注意 `匹配一个未列出的字符` 和 `不要匹配列出的字符` 的区别，排除型字符组的前者。

## 点号匹配任意字符
点号 `.` 用来匹配任意字符

例子
1. `03[-./]19[-./]76` 可以匹配 01/19/76 或者 01.19.76 或者 01-19-76 
    - 这里的 `-` 不是元字符因为在字符组的第一位
    - 这里的 `.` 也不是元字符，因为在字符组之中
2. 这里如果用 `03.19.76` 就不精确因为点号可以表示任意字符

## 多选结构
`|` 表示 '或'，能够把不同的子表达式组合成一个总的表达式。`()`括号可以用来划定多选结构的范围

`gr[ae]y` = `gr(a|e)y` = `gray | grey` 

## Egrep 的单词分界符
`\<` 和 `\>` 可以用来匹配单词分界的位置，也就是单词版本的 `^` 和 `$`

## 量词 
1. 可选项元素：问号 `?` 代表可选项元素。
    - 把问号加在一个字符后面，表示此处容许出现一个字符，也可以不出现。
    - 举个例子：`colou?r` 可以匹配 color 和 colour
2. 加号 `+` 和 星号 `*` 的作用与问号类似。
    - `+` 表示之前的紧邻元素出现一次或多次 [1, 无穷]
    - `*` 表示之前的紧邻元素出现任意多次 [0, 无穷]
3. 规定重复出现的次数
    - 用大括号 `{min,max}` 来定义重复次数的区间，称为区间量词
    - 问号对应的区间是 `{0,1}`

## 括号及反向引用
在表达式中我们使用多个括号，用 `\1`，`\2`，`\3` 表示从左到右第一，第二，第三组的括号匹配的文本。

## 转义
要匹配某个元字符，用 `\` 来转义。

<br>
***
<br>

# 第二章 入门示例拓展

这章主要介绍 perl 中的正则表达式语法。

***

## 温度表示
书中的第一个例子是匹配能表示摄氏度和华氏度的数字
1. `^[0-9]+$` 只允许整数数字出现
2. `^[0-9]?+(\.[0-9]*)?$` 带正负号的浮点数，不过不能匹配以小数点开头的的数
3. `^([-+]?[0-9]?+(\.[0-9]*)?)([CF])$` 嵌套括号
    子表达式按照左开括号 `(` 来计算顺序。
4. `(?:)` 非捕获型括号，只分组不捕获，也就是不算到顺序里

接下来我们说一说处理空格的问题
1. 如果在命令行中使用正则表达式，空格是 shell 的一个元字符，用来作为命令和参数的分隔。那么我们怎么在正则表达式中表示空格呢？shell 中的引号也是元字符，单引号中的内容不会被当做元字符来处理，所以引号可以容许我们在正则表达式中使用空格。
2. 另外有些流派中 `\s` 来表示空白，类似于制表符 `\t`。

所以我们可以进一步修改匹配温度的正则表达式:
`^([-+]?[0-9]?+(\.[0-9]*)?)\s*([CF])$`

`^([-+]?[0-9]?+(\.[0-9]*)?)\s*([CF])$/i` Perl 中的 i 修饰符告诉 Perl 进行不区分大小写的匹配。

***

## 邮件收件人
第二个例子是从邮件中获取收件人

`^From: (\s+) \(([^()])\)`

1. `(\s+)` 为第一个子表达式，其中的内容就是发件人的地址
2. `\(` 为转义后的括号，是括号字符本身
3. `([^()])` 为第二个子表达式，内容是发件人的名字

***

## 环视


如果能从右向左解决这个问题自然很方便，但是正则表达式只能从左向右处理，我们需要用"环视"特性来解决这个问题。环式结构不匹配文本中的特定位置，这与锚点 `^` 和 `$` 类似。

1. 一种类型的环视叫做“顺序环视”，从左至右查看文本，尝试匹配子表达式。`(?=)`
2. 另一种环视称作“逆序环视”，从右向左查看文本，用特殊序列 `(?<=)` 表示

`(?=Jeffery)Jeff` 可以匹配 Jeffery 而不能匹配 Jefferson

`(?=Jeffery)Jeff` = `Jeff(?=ery)` 这两者是等价的

>我们可以发现 `(?` 括号加问号用来表示特殊标志。分组不捕获`(?:)` 也是这个特殊标志开头。

问题：我们如果要将 Jeffs 改为 Jeff's
Perl 中 `s//` 表示替换，`g` 表示全局替换
1. `s/Jeffs/Jeff's/g`
2. `s/Jeff(?=s\b)/Jeff'/g` 
    `\b` 是单词分界符，这个正则相比第一个，要匹配的字符串更短了，要替换的字符串更短了，效果是一样的
3. `s/(?<=Jeff)(?=s\b)/'/g` 
    这个正则实际上并没有匹配任何字符串，匹配的是我们想要插入`'`的位置
4. `(?=s\b)(?<=Jeff)` 把两个环视结构换一下位置，匹配的结果是一样的。

第三个例子是为数值添加逗号
例如 `298444215` ，应该表达为 `298,444,215`
注意 `\w` 表示 `[a-zA-Z0-9]`，`\d` 表示数字字符

匹配左边有数字，右边的数字数是3的三倍的正则表达式 `(?<=\d)(?=(\d\d\d)+(?!\d))`
找到这样的文本后，加上逗号：`s/(?<=\d)(?=(\d\d\d)+(?!\d))/,/g`
但是这样的表达式可以匹配 “tone of 12345Hz”，但也会匹配 “the 1970s”，我们不希望如此。

另外如果不用逆序环视也可以实现:
`s/(\d)(?=(\d\d\d)+(?!\d))/$1,/g` ， 这里用了子表达式捕获的技巧

但是 `s/(\d)((\d\d\d)+\b)/$1,$2/g` 则不能实现：
1. 例如 `123456789` 只会变为 `123,456789` 因为文本在匹配了 `123,456` 以后就会从 7 这个位置开始匹配，这个时候 `789` 就不符合了，所以 7 之前是不会加入逗号的。
2. 正则表达式在完成一次迭代的时候，下一次迭代会从上一次匹配的重点开始
3. 所以环视的意义在于，检查某个位置的时候这个字符不算在匹配的字符串内。

<br>
***
<br>

# 第三章 正则表达式的特性和流派概览
这一章看得一脸懵逼啊

<br>
***
<br>

# 第四章 表达式的匹配原理




