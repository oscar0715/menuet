---
title: Java编程思想【Java系列笔记】
tags:
  - Java
categories:
  - Technology
  - Java
date: 2017-04-18 12:18:00
---

Java编程思想
<!-- more -->

***

# 第一章 面向对象

## 多态：

``` java 
class Shape {
    public void draw() {};
    public void erase() {};
    public void move() {};
}

// Circle, Squre, Triangle 继承了 Shape 

// 假设还提供了这样一个方法
void doStuff(Shape s) {
    s.erase();
    // ...
    s.draw();
}

// 以下函数也能运行良好
Circle c = new Circle();
Triangle t = new Triangle();
Line l = new Line();
doStuff(c);
doStuff(t);
doStuff(l);
```

1. “Upcasting”（上溯造型）
    - 凡是doStuff()能发给一个Shape的消息，Circle也能接收。
    - 我们将这种把衍生类型当作它的基本类型处理的过程叫作“Upcasting”（上溯造型）。
    - 其中，“cast”（造型）是指根据一个现成的模型创建；而“Up”（向上）表明继承的方向是从“上面”来的——即基础类位于顶部，而衍生类在下方展开。所以，根据基础类进行造型就是一个从上面继承的过程，即“Upcasting”。
2. 动态绑定：
    - 将一条消息发给对象时，如果并不知道对方的具体类型是什么，但采取的行动同样是正确的，这种情况就叫作“多形性”（Polymorphism）。
    - 对面向对象的程序设计语言来说，它们用以实现多形性的方法叫作“动态绑定”。编译器和运行期系统会负责对所有细节的控制


## 对象的创建和存在时间
1. 单根结构：利用单根结构，我们可以更方便地实现一个垃圾收集器。与此有关的必要支持可安装于基础类中，而垃圾收集器可将适当的消息发给系统内的任何对象。如果没有这种单根结构，而且系统通过一个句柄来操纵对象，那么实现垃圾收集器的途径会有很大的不同，而且会面临许多障碍。

<br>
***
<br>

#  第二章 一切都是对象

## 对象保存到什么地方
1. 寄存器：
    - 在处理器内部，最快。
    - 然而，寄存器的数量十分有限，所以寄存器是根据需要由编译器分配。
    - 我们对此没有直接的控制权，也不可能在自己的程序里找到寄存器存在的任何踪迹。
2. 栈：
    - 驻留于常规RAM（随机访问存储器）区域，可通过它的“栈指针”获得处理的直接支持。
    - 栈指针若向下移，会创建新的内存；若向上移，则会释放那些内存。
    - 速度仅次于寄存器
    - Java编译器必须准确地知道堆栈内保存的所有数据的“长度”以及“存在时间”。这是由于它必须生成相应的代码，以便向上和向下移动指针。
    - 这一限制无疑影响了程序的灵活性，所以尽管有些Java数据要保存在堆栈里——特别是对象句柄，但Java对象并不放到其中。
3. 堆：
    - 一种常规用途的内存池（也在RAM区域），其中保存了Java对象。
    - ，“内存堆”或“堆”（Heap）最吸引人的地方在于编译器不必知道要从堆里分配多少存储空间，也不必知道存储的数据要在堆里停留多长的时间。因此，用堆保存数据时会得到更大的灵活性。
    - 当然，为达到这种灵活性，必然会付出一定的代价：在堆里分配存储空间时会花掉更长的时间！
4. 静态存储：
    - “静态”（Static）是指“位于固定位置”（尽管也在RAM里）
    - 可用static关键字指出一个对象的特定元素是静态的。但Java对象本身永远都不会置入静态存储空间。
    - [实例方法和静态方法有什么不一样
](http://www.jianshu.com/p/ea7c44f31cdf "实例方法和静态方法有什么不一样
")
5. 常数存储：
    - 常数值通常直接置于程序代码内部。这样做是安全的，因为它们永远都不会改变。
    - 有的常数需要严格地保护，所以可考虑将它们置入只读存储器（ROM）。
6. 非RAM存储

## 特殊类型
1. 基本类型存储（primitive type）：
    - 不是用new创建变量，而是创建一个并非句柄的“自动”变量。
    - 这个变量容纳了具体的值，并置于栈中，能够更高效地存取。
2. 数组
    - 在C和C++里使用数组是非常危险的，因为那些数组只是内存块。若程序访问自己内存块以外的数组，或者在初始化之前使用内存（属于常规编程错误），会产生不可预测的后果
    - Java可以保证数组被初始化，而且不可在它的范围之外访问。
    - 由于系统自动进行范围检查，所以必然要付出一些代价：针对每个数组，以及在运行期间对索引的校验，都会造成少量的内存开销。但由此换回的是更高的安全性，以及更高的工作效率。为此付出少许代价是值得的。


## 类
1. 基本类型成员变量具有默认值，但是在方法里定义的基本类型的变量（局部变量）还是要赋一个默认值的

<br>
***
<br>

# 第三章 控制程序流程
转型：
1. 对主数据类型执行任何算术或按位运算，只要它们“比int小”（即char，byte或者short），那么在正式执行运算之前，那些值会自动转换成int。
2. 通常，表达式中最大的数据类型是决定了表达式最终结果大小的那个类型。若将一个float值与一个double值相乘，结果就是double；如将一个int和一个long值相加，则结果为long。

# 第四章 初始化和清除

**Override 区分同名方法：**
1. 自变量类型列表的顺序

**构造器：**
1. 尽管可用this调用一个构造器，但不可调用两个。
2. 构造器调用必须是我们做的第一件事情，否则会收到编译程序的报错信息。
3. 不能从构建器之外的其他任何方法内部调用一个构建器。

**成员初始化的顺序：**
1. 先初始化成员变量，再进入构造器
``` java
// 定一个 Tag 类
class Tag {
    Tag(int marker) {
        // 构造器是一个 println 函数
        System.out.println("Tag(" + marker + ")");
    }
}

// Card 类里面在三个地方定义了 new 了 Tag
class Card {
    // t1 在进入 Card 构造器之前
    Tag t1 = new Tag(1); // Before constructor
    
    Card() {
    // Indicate we're in the constructor:
        System.out.println("Card()");
        // 
        t3 = new Tag(33); // Re-initialize t3
    }

    // t2 在构造器之后
    Tag t2 = new Tag(2); // After constructor

    void f() {
        System.out.println("f()");
    }

    Tag t3 = new Tag(3); // At end
}

public class OrderOfInitialization {
    public static void main(String[] args) {
        Card t = new Card();
        t.f(); // Shows that construction is done
    }
} ///:~


// 输出结果
// Tag(1)
// Tag(2)
// Tag(3)
// Card()
// Tag(33)
// f()

// 1,2,3 在Card构造器之外，这个先初始化
// 然后进入 Card 构造器
// 然后再进行 33 的初始化

```
2. 如果有静态的成员变量，初始化要先于非静态的成员变量，无论代码顺序如何


**举例如果要创建一个名为Dog的类：**
1. 首次创建Dog对象，或者首次访问Dog类中的静态方法，或者静态字段的时候，解释器先找到`Dog.class`（在方法区）。
2. 找到`Dog.class`以后，所有 static 初始化模块都会进行，而且只进行这一次（储存在方法区里）
3. 如果 new Dog()，首先会在内存堆（Heap）中为一个 Dog 对象分配足够多的空间。
4. 将 Dog 中的所有基本类型的成员变量设为默认值
5. 然后进行成员变量的初始化
6. 最后进入构造器

**收尾和垃圾收集：**
`Finalize()`工作原理：
1. 一旦垃圾收集器准备好释放对象占用的存储空间，
2. 它首先调用`finalize()`，而且只有在下一次垃圾收集过程中，才会真正回收对象的内存.
3. 它意味着在我们不再需要一个对象之前，有些行动是必须采取的，而且必须由自己来采取这些行动。


# 第五章 访问控制

考察import语句，就会发现它只是说：“在这里可能发现了P”。然而，我们假定的是编译器搜索自己类路径的任何地方，所以一旦它发现一个P，就会使用它；若在搜索过程中`发现了“错误的”一个类`，它就会`停止搜索`。这与我们在前面表述的稍微有些区别，因为存在一些讨厌的类，它们都位于包内。而这里有一个不在包内的P，但仍可在常规的类路径搜索过程中找到。如果您遇到象这样的情况，请务必保证对于类路径的每个地方，`每个名字都仅存在一个类`。

# 第六章 类的再生
合成和继承

## 继承
但继承并非仅仅简单地复制基础类的接口了事。创建衍生类的一个对象时，它在其中包含了基础类的一个“子对象”。这个子对象就象我们根据基础类本身创建了它的一个对象。从外部看，基础类的子对象已封装到衍生类的对象里了。

在衍生类的构建器中，Java会自动插入对基础类构建器的调用。

``` java
//: Cartoon.java
// Constructor calls during inheritance
class Art {
    Art() {
        System.out.println("Art constructor");
    }
}
class Drawing extends Art {
    Drawing() {
        System.out. println("Drawing constructor");
    }
}
public class Cartoon extends Drawing {
    Cartoon() {
        System.out.println("Cartoon constructor");
    }
    public static void main(String[] args) {
        Cartoon x = new Cartoon();
    }
} ///:~


// Art constructor
// Drawing constructor
// Cartoon constructor
```

构建是在基础类的“外部”进行的，所以基础类会在衍生类访问它之前得到正确的初始化。即使没有为 Cartoon()创建一个构建器， 编译器也会为我们自动合成一个默认构建器， 并发出对基础类构建器的调用。

>如果父类没有默认构造器（无参构造器），那么必须显式调用有参构造器，否则会报错的。

 





