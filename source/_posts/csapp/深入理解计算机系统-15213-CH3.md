---
title: 深入理解计算机系统_15213_CH3
tags:
  - 15213
  - CSAPP
categories:
  - Technology
  - CSAPP
date: 2016-05-26 11:30:16
---
深入理解计算机系统
Computer Systems
A Programmer Perspective

CMU 15213

CH3 Machine-Level Representation of Programs
这篇博客基于英文版的CSAPP第三版，基于64位
<!-- more -->

***

### 练习题 3.1

| Address   | Value         | 
| -----     | -----------:  | 
| 0x100     | 0xFF          | 
| 0x104     | 0xAB          |
| 0x108     | 0x13          |
| 0x10C     | 0x11          |


| Register | Value         | 
| -----    | ------------: | 
| %rax     | 0x100         | 
| %rcx     | 0x1           |
| %rdx     | 0x3           |

| Operand       | Value         | Commet        | How                         |
| ------------- |:-------------:| :-------:     | -------------------------:  |
| %rax          | 0x100         | register      |                             |
| 0x104         | 0xAB          | absolute      |                             |
| $0x108        | 0x108         | immediate     |                             |
| (%rax)        | 0xFF          | address 0x100 |                             |
| 4(%rax)       | 0xAB          | address 0x104 | 0x100 + 4 = 0x104           |
| 9(%rax,%rdx)  | 0x11          | address 0x10C | 0x100 + 0x3 + 9 = Ox10C     |
| 260(%rcx,%rdx)| 0x13          | address 0x108 | 260=0x104|
| 0xFC(,%rcx,4) | 0xFF          | address 0x100 | 0xFC+0x1*4=0x100            |
| (%rax,%rdx,4) | 0x11          | address 0x10C | 0x100+0x3*4=0x10C           |

***

### 练习题 3.2 

| Instruction | Operand             | suffix    |    WHY          |
| -----       | :------------ :     | :-------: | -------------:  |
| mov         | %eax, (%rsp)        |  movl     |  %eax           |
| mov         | (%rax), %dx         |  movw     |  %dx            |
| mov         | $0xFF, %bl          |  movb     |  %bl            |
| mov         | (%rsp,%rdx,4),%dl   |  movb     |  %dl            |
| mov         | (%rdx), %rax        |  movq     |                 |
| mov         | %dx, %rax           |  movw     |  %dx            |

在x86-64中即使操作数是一个字节byte,一个单字word,或双字double word，储存器的引用也总是用四字长quad word的寄存器给出。

***

### 练习题 3.3 


| Instruction| Operand        | Error       |   
| -----      | :------------ :|  ---------: |   
| movb       | $0xF, (%bl)    |  cannot use %bl as address register. In 16-bit code only 16-bit registers bx, bp, si and di can be used for memory addressing                                  |   
| movl       | %ax, (%esp)    |  Mismatch between instruction suffix and register ID. %ax:16bits                     |   
| movw       | (%eax), 4(%esp)|  Cannot have both source and destination be memory references                           |   
| movb       | %ah, %sh       |  No register named %sh                   |   
| movl       | %eax, $0x123   |  Cannot have immediate as destination    |  
| movl       | %eax, %dx      |  Destination operand incorrect size. movw|   
| movb       | %si, 8(%ebp)   |  Mismatch between instruction suffix and register ID                                 |

补充：
源和目的地不能都内存引用memory
就是带()的，其实是内存引用memory。
而movw是将寄存器内的数值移动到一个源地址。
或者将一个源地址移动一个寄存器里。
或者两个寄存器之间移动。
所以，mov后的两个值，同时都带括号的情况。一定是错误的。
参考: {% link 深入理解计算机系统 习题3.3 部分汇编错误的英文翻译 http://www.dc265.com/tip/index.html 参考 %}

***

### 练习题 3.4
{% codeblock lang:C %}
src_t  *sp; // stored in %rdi
dest_t *dp; // stored in %rsi

*dp = (dest_t) *sp; 
{% endcodeblock %}

第一步，将sp所存地址对应的值存到寄存器中
存在寄存器%rax的适当命名中(%rax, %eax, %ax, %al)

| src_t          | dest_t        | Instruction                            |  
| -------------- | :----------:  |  ------------------------------------: |   
| long           | long          | movq   (%rdi), %rax; movq %rax, (%rsi) |   
| char           | int           | movsbl (%rdi), %eax; movl %eax, (%rsi) |  
| char           | unsigned      | movsbl (%rdi), %edx; movl %eax, (%rsi) |   
| unsigned char  | long          | movzbl (%rdi), %edx; movq %rax, (%rsi) |   
| int            | char          | movl   (%rdi), (%edx)           |  
| unsigned       | unsigned char | movb %al, (%edx)           |  
| unsigned       | int           | movl %eax, (%edx)          |    

指令复制的长度由dest_t决定
unsigned = unsigned int (Double word, 32bit)

{% codeblock %}
unsigned --> long 
movzbl (%rdi), %edx; 
movq %rax, (%rsi)
{% endcodeblock %}

***

### 练习题 3.5
`void decode1(int *xp, in *yp, int *zp);`

    xp at %ebp+8, yp at %ebp+12, zp at %ebp+16
    movl    8(%ebp), %edi      // get xp
    // 间接寻址
    // %ebp 是个内存地址，(%ebp)指的是该地址中的数据，edx = *(int32_t*)(ebp+8);
    // 由此看来，(%ebp+8)这个地方存了一个只想xy这个指针的地址，就是指针的指针
    //（累死），总算说通了。

    # xp at \ebpreg+8, yp at \ebpreg+12, zp at \ebpreg+16
    movl    8(%ebp), %edi   # Get xp
    movl    12(%ebp), %edx  # Get yp
    movl    16(%ebp), %ecx  # Get zp
    movl    (%edx), %ebx    # Get y
    movl    (%ecx), %esi    # Get z
    movl    (%edi), %eax    # Get x
    movl    %eax, (%edx)    # Store x at yp
    movl    %ebx, (%ecx)    # Store y at zp
    movl    %esi, (%edi)    # Store z at xp

{% codeblock lang:C %}
void decode1(int *xp, in *yp, int *zp){
    
    int tx = *xp; 
    int ty = *yp; 
    int tz = *zp; 

    *yp = tx; 
    *zp = ty; 
    *xp = tz; 
} 
{% endcodeblock %}

### 练习题 3.8
{% codeblock lang:C %}
int shift_left2_rightn(int x, int n){
    x <<= 2;
    x >>= n;
    return x;
}
{% endcodeblock %}

{% codeblock lang:C %}
movl 8(%ebp), %eax
sall $2, %eax
movl 12(%ebp), %ecx
sarl %cl, %eax 
{% endcodeblock %}










