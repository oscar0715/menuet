---
title: 深入理解计算机系统_15213_CH2
tags:
  - 15213
  - CSAPP
categories:
  - Technology
  - CSAPP
date: 2016-05-16 09:06:14
---
深入理解计算机系统
Computer Systems
A Programmer Perspective

CMU 15213

CH2 信息的表示和管理
<!-- more -->

***

### 练习题 2.48
十进制整数: 3510593 
十六进制表示: Ox00359141

单精度浮点数: 3510593.0
十六进制表示: Ox4A564504

问题: 推导出这个浮点表示，并解析整数和浮点数表示的位之间的关系

整数二进制 ==> 单精度二进制
1. 整数3510593的二进制表示:
        0000 0000 0011 0101 1001 0001 0100 0001
2. 小数点左移到最高位右边，左移21位(E=21),得到尾数M:
        1.1 0101 1001 0001 0100 0001 x 2^20 
3. 取小数部分，在末尾补2个零（因为单精度尾数为23位）, 得到f:
        1 0101 1001 0001 0100 0001 00
        // 单精度规格化的值, `M = 1+f`
5. 阶码的值 E = e-Bias， e为无符号数，此处用 E+bias 还原e:
        单精度中 Bias = 2^7-1 = 127
        e = E+Bias = 21 + 127 = 148  ==> 1001 0100
        得到单精度值二进制表示 
        0 10010100 101 0110 0100 0101 0000 0100
        与Ox4A564504 = 0 10010100 101 0110 0100 0101 0000 0100 相同

单精度二进制 ==> 整数二进制
* 换一个方向
        0 10010100 10101100100010100000100
        M = 1.10101100100010100000100
        e = 10010100b = 148
        E = 148 - 127 = 21
        小数点右移21位
        V = 1 1010 1100 1000 1010 0000 1.00

***

### 练习题 2.49
A. 对于具有n位的小数的浮点格式，给出不能准确描述的最小正整数公式，假设阶码字段长度k足够大，可以表示的阶码范围不会限制这个问题。

1. 只有规格数才能有可能出现整数，所以只考虑阶码不全为零。
2. 小数位需要n+1位才能表示，所以小数部分为 n个0加最低位的一个1，
$$f=2^{(-n-1)}$， $M=1+f=1+2^{(-n-1)}$$
3. 用阶码抵消小数部分 所以 $2^E = 2^{n+1}$
$$V=2^E \times M=(1+2^{(-n-1)}) \times 2^{n+1} = 2^{n+1}+1$$

B. 对于单精度格式23位小数位，这个整数的数字值是多少？
$$ 2^{23+1}+1 = 16,777,217$$

***
### 练习题 2.50
根据舍入到偶数原则，将下列二进制小数值舍入到最接近的二分之一（小数点后一位）
1. 10.010 ==> 10.0 （向下舍入到偶数）
2. 10.011 ==> 10.1 （舍入到最接近的）
3. 10.110 ==> 11.0 （向上舍入到偶数）
4. 11.001 ==> 11.0 （舍入到最接近的）

***

### 练习题 2.51
定义 0.1 = 0.0001 1001 1001 1001 1001 100
x =0.0001 1001 1001 1001 1001 1001 [1001]
1. 使用舍入到偶数原则 x'=0.0001 1001 1001 1001 1001 101 （舍入到最接近的）
2. x'-0.1 = 0.0000 0000 0000 0000 0000 0000 [0110] （🐶？？？？？？？）

***

### 练习题 2.52
基于IEEE浮点格式的6位浮点表示
格式A: 3个阶码位k，4个小数位n，偏置值为$2^{3-1}-1=3$
格式B: 3个阶码位k，4个小数位n，偏置值为$2^{4-1}-1=7$
给出A格式的位模式，将其转化为B格式中最接近的值


1. 011 0000
$A: 2^E=2^{3-3}=1，  <br/>M=1，  <br/>V=1 $
$B: 2^E=2^{7-7}=1，  <br/>M=1，  <br/>V=1 $
==> B: 0111 000

2. 101 1110
$A: 2^E=2^{5-3}=4，  <br/>M=\frac{14+16}{16}=\frac{15}{8}  $
$B: 2^E=2^{9-7}=4，  <br/>M=\frac{7+8}{8}=\frac{15}{8} $
==> B: 1001 111

3. 010 1001
$A: 2^E=2^{2-3}=\frac{1}{2}，  <br/>M=\frac{9+16}{16}=\frac{25}{16} ，  <br/> V=\frac{25}{32} $
1001 向下舍入==> 100
$B: 2^E=2^{6-7}=-1，  <br/>M=\frac{4+8}{8}=\frac{3}{2}，  <br/> V=\frac{3}{4}  $
==> B: 0110 100

4. 110 1111
$A: 2^E=2^{6-3}=8，  <br/>M=\frac{15+16}{16}=\frac{31}{16} ，  <br/> V=\frac{31}{2} $
1111 向上舍入==> 000
$B: 2^E=2^{11-7}=16，  <br/>M=\frac{8}{8}=1，  <br/> V=16  $
==> B: 1011 000

5. 000 0001
$A: 2^E=2^{1-3}=\frac{1}{4}，  <br/>M=\frac{1}{16}，  <br/> V=\frac{1}{64} $
0001 向下舍入==> 000
$B: 2^E=2^{1-7}=\frac{1}{64}，  <br/>M=\frac{8}{8}=1，  <br/> V=\frac{1}{64}  $
==> B: 0001 000

***

### 练习题 2.53
完成下列宏定义，生成双精度 $+\infty,-\infty$和0
双精度能够表示的最大的有限数大约是$1.8\times10^{308}$

>不懂，求解答

{% codeblock lang:C %}
#define POS_INFINITY  1e400;
#define NEG_INFINITY  (-POS_INFINITY);
#define NEG_ZERO  (-1.0/POS_INFINITY);
{% endcodeblock %}

***

### 练习题 2.54
x,f,d分别为 int,float,double类型的数字

判断以下条件
1. x==(int)(double)x  真, 因为double比int更长
{% codeblock lang:C %}
int x = pow(2,31)-1;
printf("int x = %d\n",x);
printf("(float)x = %f\n",(float)x);
printf("(int)(float)x = %d\n",(int)(float)x);

//输出
int x = 2147483647  //0x7fffffff  这个数字包含31个1,所以float没法精确标示。 为啥
(float)x = 2147483648.000000
(int)(float)x = -2147483648
{% endcodeblock %}
2. x==(int)(float)x   假, float长度和int相同,有可能溢出, 
例如TMax 0111 1111 1111 1111 1111 1111 1111 1111
float类型最多向左移动23位，也就是说float没有办法表示这么长的精度，虽然float可以表示更大范围的数。所以相对于int,float是牺牲了精度，用一些部分位当做阶码去表示更大范围的数。
3. d==(double)(float)d 假 当d=1e40时,右边为正无穷
4. f==(float)(double)f 真
5. f=-(-f) 真,浮点数正负只是改变符号位而已
6. 1.0/2=1/2.0 真，运算前，都会转换为浮点数
7. d*d >=0.0 真，虽然会溢出到$+infty$
8. (f+d)-f=d 假 浮点运算没具备结合律

***

### 练习题 2.55-2.57
{% codeblock CSAPP 2.55 lang:C %}
#include <stdio.h>

// 定义byte_pointer为一个指向 unsigned char的指针
typedef unsigned char *byte_pointer;

void show_byte(byte_pointer start, int len){
    int i;
    for (int i = 0; i < len; ++i){
        //format: 对于整型数，小数点指定打印的数字位数
        //必要时可填充位0以达到要求的宽度
        printf("%.2x",start[i] );
    }
    printf("\n");
}

void show_short(short x){
    show_byte((byte_pointer) &x, sizeof(short));
}

void show_int(int x){
    show_byte((byte_pointer) &x, sizeof(int));
}

void show_long(long x){
    show_byte((byte_pointer) &x, sizeof(long));
}

void show_float(float x){
    show_byte((byte_pointer) &x, sizeof(float));
}

void show_pointer(void *x){
    show_byte((byte_pointer) &x, sizeof(void *));
}

void test_show_byte(int val){
    int ival = val;
    float fval = (float)val;
    int *pval = &ival;
    show_int(ival);
    show_float(fval);
    show_pointer(pval);
}

int main(){
    int val = 0x87654321;
    byte_pointer valp = (byte_pointer)&val;
    show_byte(valp,1);
}

// 运行结果为21
// 我的Mac是小端法机器
{% endcodeblock %}

***

### 练习题 2.58
判断机器是否为小端法，是返回1，否返回0
{% codeblock CSAPP 2.58  lang:C%}
int is_little_end(){
    
    // 定义a占4个字节
    int a = 1; 

    // &a 取a的地址
    // (char*)&a 将int指针转换为char指针
    // *(char*)&a 取该指针所在地址的第0个字节作为一个char返回
    // *(char*)取第0个字节，因为char只占一个字节
    // *(int*)取四个字节，因为int占四个字节
    return *((char*)&a);   
}
{% endcodeblock %}
